\documentclass[11pt, journal]{IEEEtran}

% Packages
\usepackage{cite}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgf-umlcd}
\usepackage{tcolorbox}

% Title and Author
\title{SQLiteCache: A single-threaded, persistent, and high capacity key-value cache using SQLite}

\author{
    \IEEEauthorblockN{
        Christofer Washington Berruz Chungata\IEEEauthorrefmark{1},
        Mithi Pandey\IEEEauthorrefmark{2}\\
    }
    \IEEEauthorblockA{
        \textit{Department of Computer Science}, \\
        \textit{San Jos\'{e} State University}, \\
        San Jos\'{e}, California, U.S.A \\
        \IEEEauthorrefmark{1}christoferwashington.berruzchungata@sjsu.edu, \\
        \IEEEauthorrefmark{2}mithi.pandey@sjsu.edu
    }
}

\begin{document}

\maketitle

\begin{abstract}
The abstract goes here. It should summarize the key points of your paper in about 150–250 words.
\end{abstract}

\begin{IEEEkeywords}
Keyword1, Keyword2, Keyword3, Keyword4
\end{IEEEkeywords}

\newcommand{\sqlitecache}{\texttt{sqlitecache}}
\section{Introduction}
% Project goals and motivation
% Description of Database systems challenge addressed
The introduction goes here. Provide background, motivation, and an overview of the paper.

\section{Related Work}
% Survey related work in the related work section
Discuss related work and how your work differs or builds upon it.

\section{Methodology}
% Include a detailed description of your methodology, analysis, and implementation in the technical section
% o Describe key design goals in designing your database
% o Describe the key components and algorithms
% o Describe your architecture and how the components will interact.
%   You must include several UML diagrams to illustrate your design
%   (at least 3 diagrams from below list to illustrate proper overview of the system.
%   ▪ Use Case style diagram to show the overview of your system functionality and different functions in your system.
%   ▪ Use the Deployment and Component diagrams to show the software and hardware components of your system.
%   ▪ Communication diagram to illustrate the connections between the components,
%   ▪ Sequence diagram explains the sequence of actions, events, and processes between the components,
%       objects, and actors in your system.
%   ▪ Activity and State diagrams to explain more detail about a process or object in your system.

In this project, we designed and implemented a
persistent key-value cache using SQLite
that supports three eviction policies: Least Recently Used (LRU),
Least Frequently Used (LFU), and a hybrid policy combining both LRU and LFU
described in \cite{shah2023ImprovedCacheEviction}.


Our key design goals of this project are:
\begin{itemize}
    \item \textbf{Single-Threaded}: The cache should be single-threaded to simplify the design and avoid concurrency issues.
    \item \textbf{Persistent}: The cache should persist data to disk using SQLite, allowing for data recovery after a crash.
    \item \textbf{High capacity}: The cache should be able to store a large amount of data efficiently.
    \item \textbf{Eviction policies}: The cache should support LRU, LFU, and a hybrid policy for eviction.
    \item \textbf{Encryption}: The cache should support encryption to protect sensitive data.
    \item \textbf{Compression}: The cache should support compression to reduce the size of the data stored on disk.
    \item \textbf{Ease of use}: The cache should be easy to use and integrate into existing applications.
    \item \textbf{Cross-platform}: The cache should work on any platform that supports SQLite.
\end{itemize}

Our persistent cache is available as a pip installable package,
\sqlitecache, that
can be used for any Python application.
The overall design of the architecture is shown in Figure \ref{fig:architecture}.

As part of this project, we also include a simulation 
comparing the hit rate
and miss rates of the three policies to determine which one performs better
in terms of cache performance. The methodology is similar to \cite{shah2023ImprovedCacheEviction},
with the major difference that our cache is disk based and persistent,
while the cache in \cite{shah2023ImprovedCacheEviction} is memory based and not persistent.
Additionally, the authors in \cite{shah2023ImprovedCacheEviction} use an element-oriented
cache while we use a key-value cache. More details on the simulation
are provided in Section \ref{sec:simulation}.

% Overall architecture
\begin{figure}[ht]
    \centering
    \includegraphics[width=3.25in]{images/overall_architecture.png}
    \caption{Architecture of SQLiteCache}
    \label{fig:architecture}
\end{figure}

\subsection{Key Components}
The \sqlitecache~package exposes three main cache classes: LRUCache, LFUCache, and HybridCache.
Furthermore, we use the concept of a DiskStorage that is a wrapper around the filesystem
and it is used alongside SQLite to persist data to disk, as shown in Figure \ref{fig:architecture}.

These cache classes can be divided into two groups: functional caches and wrapper caches.

Both LRUCache and LFUCache are functional caches because they store data
in a combination of relations and filesystem.
HybridCache behaves like a soft wrapper around LRUCache and LFUCache because
it uses the composition pattern to combine the two caches. At any point in time,
elements in the HybridCache are stored in either LRUCache or LFUCache, but not both.
The entire inheritance hierarchy is shown in Figure \ref{fig:base_cache_uml_diagram}
and Figure \ref{fig:real_caches_uml_diagram}.


% UML inheritance diagram of the base classes
\begin{figure}
    \centering
    \begin{tikzpicture}[scale=0.45]
        % Base class
        \begin{class}[text width=6cm]{Cache}{0, 0}
            \operation{+ put(key: Hashable, value: Any): HashedKey}
            \operation{+ get(key: Hashable, default: Any): Any}
            \operation{+ delete(key: Hashable)}
            \operation{+ fits(size: int): bool}
            \operation{+ exists(key: Hashable): bool}
            \operation{+ get\_rates(): Tuple[float, float, int]}
        \end{class}

        % Derived classes
        \begin{class}[text width=4cm]{BaseCache}{0, -12}
            \inherit{Cache}
            \operation{+ connection(): sqlite3.Connection}
            \operation{+ commit\_connection(): sqlite3.Connection}
            \operation{+ cursor(): sqlite3.Cursor}
        \end{class}

        % FunctionalCache
        \begin{class}[text width=6cm]{FunctionalCache}{0, -20}
            \inherit{BaseCache}
            \attribute{+ size\_table: str}
            \attribute{+ cache\_table: str}
            \attribute{+ metadata\_table: str}
        \end{class}
    \end{tikzpicture}
    \caption{UML class diagram of the base cache classes.}
    \label{fig:base_cache_uml_diagram}
\end{figure}


% UML inheritance diagram of the real cache classes (LRUCache, LFUCache, HybridCache)
\begin{figure}
    \centering
    \begin{tikzpicture}[scale=0.45]
        % FunctionalCache
        \begin{class}[text width=5cm]{FunctionalCache}{0, 0}
            \attribute{+ size\_table: str}
            \attribute{+ cache\_table: str}
            \attribute{+ metadata\_table: str}
        \end{class}
        % LRUCache and LFUCache
        \begin{class}[text width=4cm]{LRUCache}{-4, -8}
            \inherit{FunctionalCache}
        \end{class}

        \begin{class}[text width=4cm]{LFUCache}{5, -8}
            \inherit{FunctionalCache}
        \end{class}

        % BaseCache
        \begin{class}[text width=4cm]{BaseCache}{0, -19}
            \operation{+ connection(): sqlite3.Connection}
            \operation{+ commit\_connection(): sqlite3.Connection}
            \operation{+ cursor(): sqlite3.Cursor}
        \end{class}

        % HybridCache
        \begin{class}[text width=6cm]{HybridCache}{0, -12}
            \inherit{BaseCache}
            \attribute{+ ttl: int}
            \attribute{+ treshold: int}
            \attribute{+ lru\_cache: LRUCache}
            \attribute{+ lfu\_cache: LFUCache}
        \end{class}
        \composition {HybridCache}{}{}{LRUCache}
        \composition {HybridCache}{}{}{LFUCache}
    \end{tikzpicture}
    \caption{UML class diagram showing the relation of the three policy caches
    and their relation to the base classes.}
    \label{fig:real_caches_uml_diagram}
\end{figure}


\subsection{LRUCache and LFUCache}
LRUCache and LFUCache use a combination of a database and the filesystem
to store data. For a given (key, value) pair submitted to the cache,
the cache computes a hash of the key. Hash collisions are handled by replacement
instead of chaining. Formally, the keys stored in the cache are $k' = hash(k)$,
where $k$ is the original key and $k'$ is the hashed key.
Our hashing function is defined as $$ hash(k) = PythonHash(k) \times \mathrm{0xFFFFFFFF}$$
As a result, the keys must implement the \texttt{\_\_hash\_\_} method.

Once $k'$ is computed, the database sends $v$ to the DiskStorage.
To store $v$, we first
compute its binary representation, $v_b$ using the \texttt{pickle} module.
By using pickle, we guarantee that any Python object
that can be serialized and deserialized using
the \texttt{pickle} module can be stored in the cache.
If compression is enabled, we compress the data using the \texttt{zlib} module.
If encryption is enabled, we encrypt the data using the \texttt{cryptography}
module. Once the final binary value $v_b'$ is obtained,
the DiskStorage object creates a unique
filename, $f_{name}$, using the \texttt{uuid} library.
Then, DiskStorage saves $v_b'$ into the filepath $dir/f_{name}$ where $dir$ is the directory
used to initialize the DiskStorage object. Finally, DiskStorage sends the full filepath
back to the database and the database stores the $(k', dir/f_{name})$ pair in the cache table.

Note that depending on the eviction policy of the cache, extra information
is inserted into the cache table. These differences are described in
Section \ref{sec:lru} and Section \ref{sec:lfu}.

The functionality between LRUCache and LFUCache
is similar, creating the inheritance relationship described in Figure \ref{fig:real_caches_uml_diagram}.
Furthermore, one design choice is that each cache class has its own cache table $(C)$,
metadata table $(M)$, and size table $(S)$.
This is achieved by each relation having a prefix
that is the name of the cache class. As a result, it is possible to have
one cache of each type in the same SQLite database. This is extremely useful
for testing and debugging the HybridCache class,
which uses one LRUCache and one LFUCache
as its backing caches.

\begin{tcolorbox}[colback=blue!5!white, colframe=blue!75!black, title=Note]
    To avoid confusion and complexity, it is recommended to use
    one cache instance per SQLite database.
\end{tcolorbox}

\subsubsection{Size}
Both LRUCache and LFUCache have a notion of capacity. We define capacity
as the maximum number of bytes allocated for the \textit{values} in the cache.
Let $v$ be the value to be inserted into the cache, $v_b'$
the final binary representation of $v$ after compression and encryption,
and $s_v$ the size of $v_b'$ in bytes.
Let $s_{max}$ be the maximum size
of the cache in bytes, and $s_{used}$ be the size of the cache in bytes. Assuming
there are $N$ elements stored in the cache, we define the current size of the cache
as $$ s_{used} = \sum_{i=1}^{N} s_{v_i}$$
where $s_{v_i}$ is the size of the $i$-th value in the cache.

\subsubsection{Size Tracking}
To efficiently know whether or not a new value $v$ can be inserted into the cache,
it is important to keep track of $s_{used}$. To do so, we use the size table $(S)$,
to store the current size of the cache. To always keep the size table up to date,
we use several triggers whenever new values are inserted, deleted, or
updated in the cache table $(C)$. In concrete, we have the following triggers:
\begin{itemize}
    \item \texttt{insert\_S}: This trigger is called whenever a new value $v$
        is inserted into the cache table $(C)$. $$s_{used} = s_{used} + s_v$$.
    \item \texttt{delete\_S}: This trigger is called whenever a value
        is deleted from the cache table $(C)$.
        $$s_{used} = s_{used} - s_v$$.
    \item \texttt{update\_S}: This trigger is called whenever a value
        is updated in the cache table $(C)$.
        $$s_{used} = s_{used} - s_{v_{old}} + s_v$$
        where $s_{v_{old}}$ is the size of the old value.
\end{itemize}

% Eviction Policy Subsubsection
\subsubsection{Eviction Policy}
Assume that a new value $v$ is requested to be inserted into the cache.
If $s_{used} + s_v > s_{max}$, then the cache must evict elements
until $s_{used} + s_v \leq s_{max}$. The eviction policy is cache dependent.
Refer to sections \ref{sec:lru} and \ref{sec:lfu} for more details.

\subsubsection{Persistency}
One main goal of this project is to have a cache that is \textit{persistent}.
We define persistency as the ability to recover the cache
after a crash or a power failure. In practice, this means the following.
Let $D$ and $DB$ be the directory and SQLite database used to initialize
the cache $X$. Assuming we store $(k, v)$ into $X$ and the program crashes,
it possible to initialize a new instance $X'$ of the same cache $X$ using the same
directory $D$ and database $DB$. Then, doing $X'.get(k)$ should return $v$.

\begin{tcolorbox}[colback=blue!5!white, colframe=blue!75!black, title=Note]
    It is theoretically possible to have two caches $X$ and $Y$ pointing
    to the same persistency $D$ and $DB$. However, this is not recommended
    because it can lead to data corruption and undefined behavior.
    Recall that \sqlitecache~is a single-threaded cache.
\end{tcolorbox}

\subsubsection{Settings \& Recovery}
Assume that you want to reconnect to a cache $X$ that was previously
created using the same directory $D$ and database $DB$. To do so, you can
create a new instance $X'$ using the same directory and database.

Recall that our cache has three possible settings: maximum size, encryption, and compression.

The cache $X'$ will automatically detect these settings and use them. As a result,
if a developer creates $X'$ using a different set of settings, the cache will
ignore them. All settings are unique and stored
in the metadata table $(M)$. This behavior is enforced by the UNIQUE
constraint in the metadata table $(M)$ and inserting
the settings using the \texttt{ON CONFLICT DO NOTHING} clause.

\subsection{LRUCache\label{sec:lru}}
\subsection{LFUCache\label{sec:lfu}}

\subsection{DiskStorage}

\subsection{Simulation\label{sec:simulation}}

\section{Results and Discussion}
% Describe evaluation methodology and significant results in the evaluation section
% Evaluate the selected approach and analyze why the selected approach is good?
%   Provide an intuitive description of the algorithms, their correctness and their complexity
Present your results and discuss their implications.

\section{Conclusion}
% Conclusions, lessons learned possible improvements, etc.
Summarize your findings and suggest future work.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}